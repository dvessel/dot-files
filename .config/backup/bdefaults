#!/usr/bin/env zsh
set -e

# defaults backup path.
bdpath=~/.config/backup/defaults

# $1 exit status
function shelp() {
  print -rC1 -- \
  "[backup|restore|list]      - Required action." \
  "[-k|--key] [<setting>]     - Settings key or -e is required." \
  "[-e|--existing]            - Previously backed up keys. Conflicts with -k." \
  "[-s|--search]              - Search for keys in all active settings." \
  "[-d|--domain] [<domain>]   - Settings domain, e.g., com.apple.finder." \
  "[-g|-globalDomain]         - Global domain. Conflicts with -d." \
  "[-p|--path] [<path>]       - Defaults to ~/.config/backup/defaults." \
  "[-h|--help]                - This help text."
  exit $1
}

# $1 domain
# $2 key
function sbackup() {
  local type value index plist=$bdpath/$1.plist

  # Keys from `defaults read-type` translated to values accepted by plutil.
  # Arrays and dictionaries must be added as a quoted string of xml.
  typeset -A types=(
    "Type is boolean"     -bool
    "Type is integer"     -integer
    "Type is float"       -float
    "Type is string"      -string
    "Type is data"        -data
    "Type is date"        -date
    "Type is array"       -xml
    "Type is dictionary"  -xml
  )

  if type=$types[`defaults read-type $1 $2 2>/dev/null`]; then
    if [[ ! -f $plist ]]; then
      plutil -create xml1 $plist
    fi
    # Hold keys to list later. No other way to do it AFAIK.
    if ! plutil -type SettingsIndex $plist &>/dev/null; then
      plutil -insert SettingsIndex -array $plist
    fi

    case $type in
      -bool)            typeset -A bool=( 0 false 1 true )
                        value=$bool[`defaults read $1 $2`]  ;;
      -integer|-float)  value=`defaults read $1 $2`         ;;
      *)                value="`defaults read $1 $2`"       ;;
    esac

    # Escape dots or plutil will drill into submembers.
    plutil -replace ${2//\./\\.} $type $value $plist &&
      echo "  $1 > $2 - saved"

    # Ensure the index is unique.
    if ! sgetIndex $1 | grep -qxF $2; then
      plutil -insert SettingsIndex -string $2 -append $plist
    fi
  else
    echo "? $1 ! $2 - does not exist!" >&2
  fi
}

# $1 domain
# $2 key
function srestore() {
  local value
  # Escape dots or plutil will drill into submembers.
  if value=`plutil -extract "${2//\./\\.}" xml1 -o - $bdpath/$1.plist 2>/dev/null`; then
    defaults write $1 $2 "$value" &&
      echo "  $1 < $2 - restored"
  else
    echo "!!$1 ! $2 - failed!" >&2
  fi
}

# $1 domain
# $2 key
function slist() {
  echo "  $2"
}

# $1 domain
# $2 key
function slistDomain() {
  echo "  $1"
}

# $1 domain
# $2 key
function skeyExists() {
  sgetIndex $1 | grep -qxF $2
}

# $1 domain
function sgetIndex() {
  c=`plutil -extract SettingsIndex raw $bdpath/$1.plist`
  if [[ $c > 0 ]]; then
    for n in {0..$((c-1))}; do
      plutil -extract SettingsIndex.$n raw $bdpath/$1.plist
    done
  fi
}

function sgetDomains() {
  for d in $bdpath/*.plist(N); echo $d:r:t
}

function () {
  local op key domain _path help errmsg

  # Zsh 5.8 required for -F option (exit on invalid flag).
  # Should be fine from Big Sur and up.
  zmodload zsh/zutil
  zparseopts -D -E -F - \
    {s,-search}=search \
    {e,-existing,k:,-key:}=key \
    {g,globalDomain,d:,-domain:}=domain \
    {p,-path}:=_path \
    {h,-help}=help || shelp 1

  if [[ ${#@[@]} > 0 ]]; then
    op=$1; shift 1
  fi

  [[ -n $help ]] && shelp

  [[ $op != (backup|restore|list) ]] && errmsg+=(
    "backup, restore or list action is required."
  )
  [[ $op == list && -n $domain && -n $key ]] && errmsg+=(
    "Cannot $op with $domain[1] and $key[1] !"
  )
  [[ -n $search && $op == restore ]] && errmsg+=(
    "Cannot $op with search! Omit the $search flag."
  )
  [[ -n $search && $key == (-e|--existing) ]] && errmsg+=(
    "Cannot use $key with search! Use -k <setting> instead."
  )
  [[ -z $key ]] && errmsg+=(
    "-k or -e is required."
  )
  [[ ${#key[@]} > 2 ]] && errmsg+=(
    "Conflicting keys: $key"
  )
  [[ ${#domain[@]} > 2 ]] && errmsg+=(
    "Conflicting domains: $domain"
  )
  [[ ${#@[@]} > 0 ]] && errmsg+=(
    "Unknown arguments: $@"
  )

  bdpath=${_path[-1]:-$bdpath}
  if [[ ! -d $bdpath ]]; then
    case $op in
      backup)       mkdir -p $bdpath                            ;;
      restore|list) errmsg+=("No backups found in path: $_path");;
    esac
  fi

  if [[ -n $errmsg ]]; then
    printf " %s\n" $errmsg >&2
    shelp 1
  fi

  domain=${domain[-1]/-(globalDomain|g)/NSGlobalDomain}

  if [[ -n $search ]]; then

    echo "Searching active domains for $key…"
    op=${op/list/listDomain}
    while read -r l; do
      if [[ $l =~ "^Found [0-9]+ keys in domain '([^']*)': {$" ]]; then
        _mdomain=${match[1]//Apple Global Domain/NSGlobalDomain}
        # domain filtering. Is case insensitive.
        [[ -z $domain || $_mdomain:l == $domain:l ]] &&
          m=m

      # If previously matched a domain, verify it's for the right key.
      elif [[ -n $m && $l =~ "^\"?$key[-1]\"? =" ]]; then
        s$op $_mdomain $key[-1]
        unset m
      fi
    done < <( defaults find $key[-1] )

  else

    # list all domains for a given key.
    if [[ $op == list && ${#key[@]} > 1 ]]; then
      echo "Getting domains for $key…"
      while read -r d; do
        skeyExists $d $key[-1] &&
          echo "  $d"
      done < <( sgetDomains )

    # [backup|restore] a specific key for specific domain.
    elif [[ -n $domain && ${#key[@]} > 1 ]]; then
      echo "Getting $key[-1] for $domain…"
      s$op $domain $key[-1]

    else
    # [backup|restore|list] from saved keys. One filter allowed.
    # - filter by domain - applies to all keys within a domain.
    # - filter by key    - applies to a key across all domains.
      while read -r d; do
        echo "Getting existing keys for $d…"
        while read -r k; do
          if [[ -z $domain || $domain == $d ]] &&
             [[ ${#key[@]} = 1 || $key[-1] == $k ]]; then
            s$op $d $k
          fi
        done < <( sgetIndex $d )
      done < <( [[ -n $domain ]] && echo $domain || sgetDomains )

    fi
  fi
} $@
