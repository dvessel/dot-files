#!/usr/bin/env zsh
set -e

# - Make sure full disk access is enabled for the terminal app so
#   defaults can read from sandboxed apps and their containers.
# - Doesn't account for hosts or -currentHost. I have not run into a any
#   problems without it but there are some settings where it's needed.

# Tested on MacOS 13 Ventura.
# - Uses features in Zsh 5.8, installed with 11 Big Sur.
# - Uses features in plutil available in 10.2 Jaguar.

# $1 exit status
function shelp {
  print -rC1 -- \
  "[backup|restore|list|delete] - Required action." \
  "[-a|--all]                   - Acts on all keys/domains from existing backups." \
  "[-s|--search]                - Search for keys in active settings." \
  "                               Use to list/save keys not previously backed-up." \
  "[-k|--key] [<setting>]       - Settings key to act on." \
  "[-d|--domain] [<domain>]     - Target a domain, e.g., com.apple.finder." \
  "[-g|-globalDomain]           - Global domain. Conflicts with -d." \
  "[-p|--path] [<path>]         - Defaults to ~/.config/backup/defaults." \
  "[-h|--help]                  - This help text."
  exit $1
}

# $1 domain
# $2 key
# $3 output 1 = domain or 2 = key
function sbackup {
  local type value index plist=$bdpath/$1.plist

  if ! ssourceDomainExists $1; then
    echo "? $1 - `serror source domain does not exist!`"
    return 1
  fi

  # Keys from `defaults read-type` translated to values accepted by plutil.
  # Data, date, arrays and dictionaries must be added as xml.
  typeset -A types=(
    "Type is boolean"     -bool
    "Type is integer"     -integer
    "Type is float"       -float
    "Type is string"      -string
    "Type is data"        -xml
    "Type is date"        -xml
    "Type is array"       -xml
    "Type is dictionary"  -xml
  )

  if type=$types[`defaults read-type $1 $2 2>/dev/null`]; then
    if [[ ! -f $plist ]]; then
      plutil -create xml1 $plist
    fi
    # Hold keys to list later. No other way to do it AFAIK.
    if ! plutil -type SettingsIndex $plist &>/dev/null; then
      plutil -insert SettingsIndex -array $plist
    fi

    case $type in
      -bool)            typeset -A bool=( 0 false 1 true )
                        value=$bool[`defaults read $1 $2`]  ;;
      -integer|-float)  value=`defaults read $1 $2`         ;;
      -xml)             value="`defaults export $1 - |
                        plutil -extract "${2//\./\\.}" xml1 -o - -- -`" ;;
      *)                value="`defaults read $1 $2`"       ;;
    esac

    # Escape dots or plutil will drill into submembers.
    if plutil -replace "${2//\./\\.}" $type $value $plist; then
      echo "  $@[$3] - `sok saved`"
      if ! sgetSettingsIndex $1 | grep -qx $2; then
        plutil -insert SettingsIndex -string $2 -append $plist
      fi
    fi
  else
    echo "? $@[$3] - `serror source key does not exist!`" >&2
    return 1
  fi
}

# $1 domain
# $2 key
# $3 output 1 = domain or 2 = key
function srestore {
  if ! ssourceDomainExists $1; then
    echo "? $1 - `serror restore target does not exist!`"
    return 1
  fi
  local value
  if value=`plutil -extract "${2//\./\\.}" xml1 -o - $bdpath/$1.plist 2>/dev/null`; then
    defaults write $1 $2 "$value" &&
      echo "  $@[$3] - `sok restored`"
  else
    echo "!!$@[$3] - `serror failed reading backup!`" >&2
    return 1
  fi
}

# $1 domain
# $2 key
# $3 output 1 = domain or 2 = key
function sdelete {
  if l=`sgetSettingsIndex $1 | grep -nx $2`; then
    plutil -remove SettingsIndex.$((${l/:*} - 1)) $bdpath/$1.plist
    plutil -remove "${2//\./\\.}" $bdpath/$1.plist &&
      echo "  $@[$3] - `sok deleted`"
  else
    echo "!!$@[$3] - `serror backup key does not exist!`" >&2
    return 1
  fi
}

# $1 domain
# $2 key
function slist {
  echo "  $2"
}

# $1 domain
# $2 key
function slistDomain {
  echo "  $1"
}

# $1 domain
# $2 key
function sbackupKeyExists {
  sgetSettingsIndex $1 | grep -qx $2
}

# $1 domain
function ssourceDomainExists {
  if [[ -z $_dd ]]; then
    _dd=`defaults domains`; _dd=${_dd//, /\\n}
  fi
  [[ $1 == NSGlobalDomain ]] &&
    return 0 ||
    echo $_dd | grep -qx $1
}

# $1 domain
function sgetSettingsIndex {
  c=`plutil -extract SettingsIndex raw $bdpath/$1.plist`
  if [[ $c > 0 ]]; then
    for n in {0..$((c-1))}; plutil -extract SettingsIndex.$n raw $bdpath/$1.plist
  fi
}

function sgetBackupDomains {
  for d in $bdpath/*.plist(N); echo $d:r:t
}

function sheader {
  # Uppercase first character.
  echo "\e[1;30m${(C)1::1}${1:1}\e[0m"
}
function serror {
  printf "\e[0;31m%s\e[0m" "${(j[ ])@}"
}
function sok {
  printf "\e[0;32m%s\e[0m" "${(j[ ])@}"
}
function swarn {
  printf "\e[0;33m%s\e[0m" "${(j[ ])@}"
}

function {
  local op key domain search all _path help errmsg

  # Zsh 5.8 required for -F option (exit on invalid flag).
  zmodload zsh/zutil
  zparseopts -D -E -F - \
    {a,-all}=all \
    {s,-search}=search \
    {k:,-key:}=key \
    {g,globalDomain,d:,-domain:}=domain \
    {p,-path}:=_path \
    {h,-help}=help || shelp 1

  if [[ ${#@[@]} > 0 ]]; then
    op=$1; shift 1
  fi

  [[ -n $help ]] && shelp

  [[ $op != (backup|restore|list|delete) ]] && errmsg+=(
    "backup, restore, list or delete action is required."
  )
  [[ $op == (backup|restore|delete) && ! -n $key$domain$all ]] && errmsg+=(
    "$op requires a key, domain or the -a flag."
  )
  [[ -n $search && -z $key ]] && errmsg+=(
    "Search requires a key."
  )
  [[ -n $search && $op == (restore|delete) ]] && errmsg+=(
    "Cannot $op with search! Omit the $search flag."
  )
  [[ $op == list && -n $domain && -n $key ]] && errmsg+=(
    "Cannot list with $domain[1] and $key[1] !"
  )
  [[ ${#domain[@]} > 2 ]] && errmsg+=(
    "Conflicting domains: $domain"
  )
  [[ ${#@[@]} > 0 ]] && errmsg+=(
    "Unknown arguments: $@"
  )

  bdpath=${_path[-1]:-~/.config/backup/defaults}
  if [[ ! -d $bdpath ]]; then
    case $op in
      backup)       mkdir -p $bdpath                            ;;
      restore|list) errmsg+=("No backups found in path: $_path");;
    esac
  fi

  if [[ -n $errmsg ]]; then
    printf " %s\n" $errmsg >&2
    shelp 1
  fi

  domain=${domain[-1]/-(globalDomain|g)/NSGlobalDomain}

  if [[ -n $search ]]; then

    sheader "Searching active domains for $key:"
    # [backup|list] from search.
    op=${op/list/listDomain}
    while read -r l; do
      if [[ $l =~ "^Found [0-9]+ keys in domain '([^']*)': {$" ]]; then
        _mdomain=${match[1]//Apple Global Domain/NSGlobalDomain}
        # domain filtering. Is case insensitive.
        if [[ -z $domain || $_mdomain:l == $domain:l ]]; then
          m=m
        fi
      # If previously matched a domain, verify it's for the right key.
      elif [[ -n $m && $l =~ "^\"?$key[-1]\"? =" ]]; then
        s$op $_mdomain $key[-1] 1
        unset m
      fi
    done < <( defaults find $key[-1] )

  else

    # list all domains for a given key.
    if [[ $op == list && -n $key ]]; then
      sheader "$op domains for $key:"
      while read -r d; do
        ! sbackupKeyExists $d $key[-1] ||
          echo "  $d"
      done < <( sgetBackupDomains )

    # [backup|restore|delete] a specific key for specific domain.
    elif [[ -n $domain && -n $key ]]; then
      sheader "$op $key[-1] for $domain:"
      s$op $domain $key[-1] 2

    else
    # [backup|restore|list|delete] from saved keys. One filter allowed.
    # - filter by domain - applies to all keys within a domain.
    # - filter by key    - applies to a key across all domains.
      while read -r d; do
        while read -r k; do
          if [[ -z $domain || $domain == $d ]] &&
             [[ -z $key || $key[-1] == $k ]];
          then
            if [[ -z $h ]] && h=h; then
              sheader "$op ${key[-1]:-keys} for $d:"
            fi
            s$op $d $k 2
          fi
        done < <( sgetSettingsIndex $d )
        unset h
      done < <( [[ -n $domain ]] && echo $domain || sgetBackupDomains )

    fi
  fi
} $@
