#!/usr/bin/env zsh

_brew_check tag libxmlb || return 1

function color-tags {
  typeset -a tags
  for t in $@; do
    case $t in
      *Preliminary) tags+="\033[0;35m$t\033[0m" ;;
      *BIOS)        tags+="\033[0;33m$t\033[0m" ;;
      *Device)      tags+="\033[0;33m$t\033[0m" ;;
      *Incomplete)  tags+="\033[0;31m$t\033[0m" ;;
      +*)           tags+="\033[0;32m$t\033[0m" ;;
      -*)           tags+="\033[4;31m$t\033[0m" ;;
    esac
  done
  printf "${(j[,])tags}"
}

function format-missing {
  printf "[%s] %s" $1 "`xpath-query "machine/description/text()" ${1%/*}`"
}

function mame-version {
  if type mame &>/dev/null; then
    local version=`mame -version`
    # Remove decimals and truncate. MAME version 0.250.0.1 results in 0250.
    print -- ${${${${version}/./}%%.*}%% *}
  fi
}

# 1 xpath query string
# 2 machine name, defaults to $CURRENT
function xpath-query {
  local result h=`md5 -qs "${2:-$CURRENT}/$1"`

  if [[ -f $hashdir/$h ]]; then
    cat $hashdir/$h
    return
  fi

  if result=`xb-tool query $xmlb "mame/machine[@name='${2:-$CURRENT}']" 1`; then
    # redirects to hash file and stdout. stderr goes nowhere but stderr.
    print -- ${result/RESULT:/} | xpath -q -n -e $1 >&1 >> $hashdir/$h
  elif [[ $result =~ "^no results" ]]; then
    f=( $scandir/${2:-$CURRENT}.(zip|7z|chd)(N) )
    print -- $f >> $cachedir/unknown
    return 1
  else
    printf "failed query: xb-tool query \n  %s\n  %s\n" $xmlb "mame/machine[@name='${2:-$CURRENT}']" >&2
    return 1
  fi
}

function xmlb-get {
  local work_path=$cachedir:h
  local xml_path=$work_path/mame${version}.xml
  local xmlb_path=$work_path/mame${version}.xmlb
  typeset -g xmlb=$xmlb_path

  [[ ! -f $xmlb_path ]] || return

  local url=https://github.com/mamedev/mame/releases/download/mame${version}/mame${version}lx.zip
  local archive=$work_path/mame${version}lx.zip

  print "Getting xml file for ver.${version}…"
  # Check for existing archive and make sure it's not corrupt.
  if test ! -f $archive || ! unzip -tqq $archive &>/dev/null; then
    if ! curl -o /dev/null --silent --head --fail $url || ! curl -#Lo $archive $url; then
      print "Failed to download 'mame${version}lx.zip'. Check version number and try again." >&2
      return 1
    fi
  fi

  if [[ ! -f $xml_path ]]; then
    unzip -oq $archive -d $work_path

    print "Compiling mame${version}.xmlb…\n"
    if xb-tool -t machine compile $xmlb_path $xml_path; then
      rm $xml_path
    else
      rm $xmlb_path
      print "Failed to compile mame${version}.xmlb." >&2
      return 1
    fi
  fi
}

# Main #########################################################################

zparseopts -D -E -F - \
  {v,-version}:=version \
  {d,-dry-run}=dryrun \
  {c,-clear-cache}=ccache || return 1

version=${version[-1]:-`mame-version`}
scandir=${${1:a}:-`eval print $(mame -showconfig|awk '$1=="rompath" {$1="";print $0}')`}
cachedir=${TMPDIR}oemame/cache-$version

if [[ ! -d $scandir ]]; then
  print "Scan directory does not exist:\n$scandir"  >&2
  return 1
fi

if [[ -z $version ]]; then
  print "Could not determine MAME version. Use --version <number>" >&2
  return 1
fi

xmlb-get
[[ -f $xmlb ]] || return 1

# tags directory is dependent on the contents of the scan directory.
tagsdir=$cachedir/tags-`md5 -qs "$(readlink -f $scandir)"`
depsdir=$cachedir/deps
# very expensive to build.
hashdir=$cachedir/hashes

# rebuild tags directory if the scan directory was modified or forced to clear.
if [[ -n $ccache || ! $tagsdir -nt $scandir ]]; then
  rm -rf $tagsdir
fi
mkdir -p $tagsdir $depsdir $hashdir

for f in $scandir/*.(zip|7z|chd)(N.); do
  # CURRENT's scope extends to other functions.
  CURRENT=$f:t:r

  currentdeps=$depsdir/$CURRENT.deps
  if [[ ! -f $currentdeps ]]; then
    touch $currentdeps

    # get chain of dependencies from bios/devices to clones for CURRENT.
    while read -r dep; do
      print -- $dep >> $currentdeps
    done < <(
      # get device dependency.
      while read -r device; do
        # device crc means it's been dumped.
        if (( `xpath-query "boolean(machine/rom/@crc)" $device` )); then
          print -- $device
        fi
      done < <( xpath-query "machine/device_ref/@name" | sort | uniq | sed 's/.*name="\(.*\)"/\1/1' )

      # get rom dependency. clones will look for parents and parents/clones will look for bios.
      romof=`xpath-query "string(machine/@romof)" $CURRENT`
      while [[ -n $romof ]]; do
        if (( `xpath-query "boolean(machine/rom/@crc)" $romof` )); then
          print -- $romof
        fi
        romof=`xpath-query "string(machine/@romof)" $romof`
      done

      # get dependent chd for CURRENT & parent.
      for set in $CURRENT `xpath-query "string(machine/@cloneof)"`; do
        while read -r disk; do
          # merge names are inherited from a parent set. Ignore!
          if ! (( `xpath-query "boolean(machine/disk/@merge)" $set` )); then
            print -- $set/$disk
          fi
        done < <( xpath-query "machine/disk/@name" $set | sed 's/.*name="\(.*\)"/\1/1' )
      done
    )
  fi

  currenttags=$tagsdir/$CURRENT.tags
  if [[ ! -f $currenttags ]]; then
    touch $currenttags
    ftags=( "MAME Preliminary" "MAME BIOS" "MAME Device" "MAME Incomplete" )

    if (( `xpath-query "boolean(machine/driver[@status='preliminary'])"` )); then
      print -- "MAME Preliminary" >> $currenttags
    fi
    if (( `xpath-query "boolean(machine[@isbios='yes'])"` )); then
      print -- "MAME BIOS" >> $currenttags
    elif (( `xpath-query "boolean(machine[@isdevice='yes'])"` )); then
      print -- "MAME Device" >> $currenttags
    fi

    # tag chain of dependencies from clones to bios/devices.
    unset __incomplete
    while read -r dep; do
      # incomplete dependencies checked early for presentation order.
      __files=( $scandir/$dep.(zip|7z|chd)(N.) )
      if [[ -z $__files && ! -v __incomplete ]]; then
        print -- "MAME Incomplete" >> $currenttags
        __incomplete=1
      fi
      ftags+=( \+$dep \-$dep )
      if [[ -n $__files ]]; then
        print -- "\+$dep" >> $currenttags
      else
        print -- "\-$dep" >> $currenttags
        printf "%s requires %s\n" "`format-missing $CURRENT`" "`format-missing $dep`" >> $cachedir/missing
      fi
    done < <( cat $depsdir/$CURRENT.deps )
  fi

  if [[ -s $currenttags ]]; then
    IFS=$'\n'
    tags=( `cat $currenttags` )
    if [[ -z $dryrun && -n $ftags ]]; then
      # do not alter tags set outside of this script.
      filetags=( `tag -gN $f` )
      othertags=( ${filetags:|ftags} )
      a=( `print -l -- ${filetags:|othertags} | sort` )
      b=( `print -l -- $tags | sort`)
      if [[ $a != $b ]]; then
        tag -r ${(j[,])a} $f
        tag -a ${(j[,])tags} $f
      fi
    fi
    printf "%-20s %s\n" $f:t `color-tags $tags`
  fi

done

# Cleanup ######################################################################

for i in missing unknown; [[ -f $cachedir/$i ]] && {
  printf "\n[%s] %s in '%s':\n%s\n" \
    "`date -u +%Y-%m-%dT%H:%M:%SZ`" "$i" "${scandir:a}" \
    "`cat $cachedir/$i | uniq`" | tee -a $cachedir/$i-history.txt
  rm $cachedir/$i
}
